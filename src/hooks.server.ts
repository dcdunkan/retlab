import { DAY, MINUTE } from "$lib";
import * as auth from "$lib/server/auth";
import { prisma } from "$lib/server/prisma";
import { error, redirect } from "@sveltejs/kit";

export const handle = async ({ event, resolve }) => {
	event.locals.session = null;
	event.locals.sessionId = null;

	console.log(event.request.method, event.url.pathname);

	// if there is an unexpired access token cookie, verify it
	try {
		const accessTokenCookie = event.cookies.get(auth.ACCESS_TOKEN_COOKIE_NAME);
		// console.log("using access token");
		if (accessTokenCookie == null) throw new Error("pass to catch");
		const { payload } = await auth.verifyAccessToken(accessTokenCookie);
		event.locals.sessionId = payload.sessionId;

		// const exp = payload.exp! * 1000;
		// const now = Date.now();
		// console.log(now, exp - now);
		// console.log("access token verified");
	} catch {
		// console.log("access token verification failed");

		// if the access token verification fails, then try the refresh token
		const refreshTokenCookie = event.cookies.get(auth.REFRESH_TOKEN_COOKIE_NAME);

		if (refreshTokenCookie != null) {
			// console.log("using refresh token");
			// if its not expired yet, verify it:
			try {
				// if the refresh token is still valid, generate the new tokens
				const { payload } = await auth.verifyRefreshToken(refreshTokenCookie);
				// const exp = payload.exp! * 1000;
				// const now = Date.now();
				// console.log(now, exp - now);
				// console.log("refresh token verified");
				// todo: should the payload be regenerated by connecting to db?
				event.cookies.set(
					auth.ACCESS_TOKEN_COOKIE_NAME,
					await auth.createAccessToken({ sessionId: payload.sessionId }),
					{
						path: "/",
						expires: new Date(Date.now() + 10 * MINUTE),
						secure: import.meta.env.PROD
					}
				);
				event.cookies.set(
					auth.REFRESH_TOKEN_COOKIE_NAME,
					await auth.createRefreshToken({ sessionId: payload.sessionId }),
					{
						path: "/",
						expires: new Date(Date.now() + 60 * DAY),
						secure: import.meta.env.PROD
					}
				);
				event.locals.sessionId = payload.sessionId;
			} catch {
				// console.log("refresh token verification failed");
				event.cookies.delete(auth.ACCESS_TOKEN_COOKIE_NAME, {
					path: "/",
					secure: import.meta.env.PROD
				});
				event.cookies.delete(auth.REFRESH_TOKEN_COOKIE_NAME, {
					path: "/",
					secure: import.meta.env.PROD
				});
				event.locals.sessionId = null;
			}
		}
	}

	// if the user have been authenticated:
	if (event.locals.sessionId != null) {
		// console.log("auth successful");
		if (event.route.id == "/login") {
			// todo: refactor for all "non-protected" routes
			redirect(307, "/");
		}

		const dbSession = await prisma.session.findFirst({
			where: { id: event.locals.sessionId },
			include: { account: { include: { college: true } } }
		})!;
		if (dbSession == null) {
			event.cookies.delete(auth.ACCESS_TOKEN_COOKIE_NAME, {
				path: "/",
				secure: import.meta.env.PROD
			});
			event.cookies.delete(auth.REFRESH_TOKEN_COOKIE_NAME, {
				path: "/",
				secure: import.meta.env.PROD
			});
			event.locals.sessionId = null;
			redirect(307, "/login");
		}
		const { account, ...session } = dbSession;
		event.locals.session = {
			...session,
			account: account
		};
		return resolve(event);
	} else {
		// console.log("unauthorized");
		if (event.route.id == "/login") {
			return resolve(event);
		}
		redirect(307, "/login");
	}

	error(500, "Impossible!");
};
